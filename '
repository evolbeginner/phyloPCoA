#! /bin/env Rscript

#Sishuo's idea on accounting phylogeny for proportion data


###############################################################
# Update history
# 2025-10-24
#   Rho solved by forcing v%*%v' where v iid~ U(0.5,1).
# 2025-10-22
#   R improved with nearPD
#   re-organized into functions
#   pcoa plots with polygon
# 2025-10-21
#   greatly improved!
#   now prop, abun, log_prop_geomean to replace Q, Y, P
# 2025-07-18
#   some wrapping of the code to make it easier to read
#   -T 30 -B 8 -p 0.2
# 2025-07-16_2
#   some more updates for XQ
# 2025-07-16_1
#   some small update for XQ
# 2024-11-21
#   pcoa_plot
#   check_BM
# 2024-11-14
#   --all, --one
# 2024-10-29
#   pcoa sim
# 2024-10-26
#   Expectation transformed_X <- t(t(X)-root_values)
#   Cholesky decomposition corrected!
# 2024-10-25:
#   Expectation after phylo_var transform updatd (Sishuo)
#   pb() to generate traits
#   TreeSim to generate random tree, where lambda and mu to ctrl for "phylogenetic relateness"
#   X <- L %*% YY instead of t(L) for Cholesky decomposition
#   C^(-0.5) %*% X may be also fine
# 2024-09:
#   Initiated (Youhua Chen)


###############################################################
#set.seed(2)
suppressPackageStartupMessages({
    library(getopt)
    library(dplyr)
    library(tidyr)

    library(TreeSim)
    library(mvMORPH)
    library(phytools)
    library(phangorn)

    library(adephylo)
    library(vegan)
    library(labdsv) #pco
    library(compositions) #clr

    library(Matrix)
    library(MASS)
})


##################################
calculate_pcoa <- function(X, method = "bray", scaled=FALSE, grp_list) {
    if(scaled == TRUE){X <- scale(X)}
    distance <- vegdist(X, method = method)
    pcoa_res <- cmdscale(distance, eig = T, k = 2)

    lda_input <- as.data.frame(pcoa_res$points)
    group_map <- unlist(lapply(names(grp_list), function(g) {
        setNames(rep(g, length(grp_list[[g]]$labels)), grp_list[[g]]$labels)
    }))
    sample_names <- names(group_map)
    grp_factor <- factor(group_map[sample_names])
    lda_model <- lda(grp_factor ~ ., data = lda_input)
    lda_pred <- predict(lda_model)
    #print(table(True = grp_factor, Pred = lda_pred$class))
    #print(summary(aov(V1 ~ group, data = cbind(as.data.frame(pcoa_res$points), group = grp_factor))))

    coords <- as.data.frame(pcoa_res$x[, 1:2])  # we only need first two PCs

    return(pcoa_res)
}


generate_metadata <- function(metadata_file){
    metadata <- read.table(metadata_file, header = T)
    # Randomly select one sample_id for each species
    selected_samples <- metadata %>%
        group_by(species) %>%
        slice(1) #always the 1st, reproducible
        #sample_n(1)  # Sample one row from each group
    return(selected_samples)
}

generate_metadata2 <- function(metadata_file, abundance){
    metadata <- read.table(metadata_file, header = T)
    abundance$taxon <- rownames(abundance)
    rownames(abundance) <- NULL
    abundance_long <- abundance %>%
        pivot_longer(cols = -taxon, names_to = "sample_id", values_to = "abundance")
    merged_data <- inner_join(abundance_long, metadata, by = "sample_id")
    merged_data <- merged_data %>%
        group_by(sample_id) %>%
        mutate(abundance = abundance / sum(abundance)) %>%
        ungroup()

    average_abundance <- merged_data %>%
      group_by(species, taxon) %>%
      summarize(average_abundance = mean(abundance), .groups = 'drop')
      #summarize(average_abundance = first(abundance), .groups = 'drop')
      #summarize(average_abundance = exp(mean(log(abundance+1e-5), na.rm = TRUE)), .groups = 'drop')

    # Reshape the average_abundance data frame to wide format
    average_abundance_wide <- average_abundance %>%
      pivot_wider(names_from = species, values_from = average_abundance)

    average_abundance_wide = as.data.frame(average_abundance_wide)
    rownames(average_abundance_wide) <- average_abundance_wide[,1]
    average_abundance_wide <- average_abundance_wide[,-1]

    return(average_abundance_wide)
}


simulate_covariance <- function(n, rate = 1,
	weak_range = c(-0.1, 0.1),
	strong_range = c(0.4, 0.8),
	split_quantile = 0.5) {
	
	# 1. Draw standard deviations (σ_i ~ Exp(rate))
	sigma <- rexp(n, rate = rate)
	#sigma <- rep(1/rate, n)
    sigma[length(sigma)] <- sigma[length(sigma)]
	
	# 2. Initialize correlation matrix
	#Rho <- matrix(runif(n * n, -1, 1), n, n)
	Rho <- matrix(runif(n * n, 0.5, 1), n, n)
	Rho <- (Rho + t(Rho)) / 2
	diag(Rho) <- 1
	
	# 3. Quantile-based split index
	split_index <- ceiling(n * split_quantile)
	
	weak_idx <- 1:split_index
	strong_idx <- min((split_index+1),n):n
	
	# 4. Adjust correlations for last column
	Rho[weak_idx, n] <- runif(length(weak_idx), weak_range[1], weak_range[2])
	Rho[strong_idx, n] <- runif(length(strong_idx), strong_range[1], strong_range[2])
	Rho[n, ] <- Rho[, n]
    write.table(round(Rho,3), file.path(outdir, "Rho_old.tbl"))
	
	# 5. Build covariance
	D <- diag(sigma)
	Sigma <- D %*% Rho %*% D
	Sigma <- as.matrix(Matrix::nearPD(Sigma)$mat)
    Rho <- cov2cor(Sigma)
	
	return(list(Sigma=Sigma, Rho=Rho))
}


simulate_covariance2 <- function(n, rate = 1,
                                weak_range = c(-0.1, 0.1),
                                strong_range = c(0.4, 0.8),
                                split_quantile = 0.5) {
  # 1. Split indices
  split_idx <- ceiling(n * split_quantile)
  weak_idx   <- 1:split_idx
  strong_idx <- (split_idx + 1):n
  
  # 2. Build factor loadings that produce desired correlations
  loadings <- rep(0, n)
  loadings[weak_idx]   <- runif(length(weak_idx), weak_range[1], weak_range[2])
  loadings[strong_idx] <- runif(length(strong_idx), strong_range[1], strong_range[2])
    if(length(loadings)>n){
        loadings <- loadings[-length(loadings)]
    }
  
  # 3. Correlation from single common factor + unique variance
  Rho <- outer(loadings, loadings)
  diag(Rho) <- 1
  # unique variance so total correlation structure realistic
  Rho <- Rho + diag(1 - diag(Rho))
  
  # slight random jitter to avoid perfect structure
  Rho <- Rho + matrix(rnorm(n^2, 0, 0.02), n, n)
  Rho <- (Rho + t(Rho))/2
  diag(Rho) <- 1
  write.table(round(Rho,3), file.path(outdir, "Rho_old.tbl"))
  
  # 4. Force PD (small shrink only)
  Rho <- as.matrix(Matrix::nearPD(Rho, corr = TRUE)$mat)
  
  # 5. Create covariance with arbitrary SDs
  sigma <- rexp(n, rate)
    print("Sigma:")
    print(sigma)
  Sigma <- diag(sigma) %*% Rho %*% diag(sigma)
  
  return(list(Rho = Rho, Sigma = Sigma))
}


simulate_covariance3 <- function(n=5, rate = 1, exponent = 4) {
  # Step 1: Generate random orthogonal basis (once)
  Q <- qr.Q(qr(matrix(rnorm(n^2), n)))
  
  # Step 2: Baseline eigenvalues
  base_eigs <- rexp(n, rate = 1)
  base_eigs <- base_eigs / max(base_eigs)  # scale m1 = 1
  
  # Step 3: For each exponent, build scaled covariance matrix
    eigs_a <- base_eigs^exponent       # apply exponent
    eigs_a <- eigs_a / mean(eigs_a)  # normalize total variance if desired
    Rho <- cov2cor(Q %*% diag(eigs_a) %*% t(Q))

    sigma_sq <- sqrt(rexp(n, rate = rate))
    #print(sigma_sq)
    Sigma <- diag(sigma_sq) %*% Rho %*% diag(sigma_sq)
  
  return(list(Rho=Rho, Sigma=Sigma))
}



# XQ
# bnum: bac taxonomic unit # in the microbiota
# tnum: tip (host) species
do_sim <- function(tnum, bnum, lambda, mu, rho, age){
    # BD model
    trees <- sim.bd.taxa.age(tnum, 1, lambda, mu, rho, age)
    tree <- trees[[1]]
    write.tree(tree, file=file.path(outdir, 'sim.tree'))

    # diff root_values
    mean_a=0; sd_a=1; nsim=bnum
    abundance <- matrix(0, nrow = tnum, ncol = nsim); 

    # generate matrix R (randomly)
    scale_R <- 1/distRoot(tree)[1]
    # XQ, R controls sigma in mvSIM() (covariance matrix)
    #R <- crossprod(matrix(runif(bnum*bnum),bnum)) * scale_R
    #sim_cov_res <- simulate_covariance2(bnum, rate=1/scale_R, weak_range=c(-0.01,0.01), strong_range=c(0.8,1), split_quantile=0.2)

    # Uyeda2015
    sim_cov_res <- simulate_covariance3(bnum, rate=1/scale_R, exponent=4)
    Sigma <- sim_cov_res$Sigma
    Rho <- sim_cov_res$Rho

    rs <- rnorm(ncol(Sigma), mean_a, sd_a) # diff root_values, XQ
    abundance <- exp(mvSIM(tree, model="BM1", nsim=1, param=list(sigma=Sigma, theta=rs)))
    log_abundance <- abundance

    above_names <- get_binary(abundance, rs) #last column above root value

    # remove the last column (binary trait, not microbial abundance)
    num_cols <- ncol(abundance)
    abundance <- abundance[, 1:(num_cols - 1)]

    a_values <- rnorm(nsim, mean = mean_a, sd = sd_a)
    C <- vcv(tree)
    abun <- abundance
    prop <- t(apply(abundance, 1, function(x) x/sum(x)))

    return(list(abundance=abundance, abun=abun, prop=prop, C=C, 
        above_names=above_names, tree=tree, 
        Sigma = Sigma, Rho = Rho,
        above_names=above_names)
    )
}


get_binary <- function(abundance, rs){
    root_value <- rs[length(rs)]
    n_trait <- dim(abundance)[2]
    a <- log(abundance[, n_trait]) - root_value
    v <- rep(0, length(a))
    v[a>0] <- 1
    names(v) <- rownames(abundance)
    return(names(v[v>0]))
}


sim_wrapper <- function(tnum=10, bnum=8, filter_BM_P=1, lambda=1, mu=1, rho=0.001, age=1){
    do_sim_res <- do_sim(tnum, bnum, lambda, mu, rho, age)
    abundance <- do_sim_res$abundance
    abun <- do_sim_res$abun
    prop <- do_sim_res$prop
    C <- do_sim_res$C
    tree <- do_sim_res$tree
    above_names <- do_sim_res$above_names; cat("above zero:\t", above_names, "\n")

    # XQ: set P-value for brownian motion checking (e.g., "-p 0.1")
    if(filter_BM_P < 1){
        phylo_sig <- check_BM(abundance, tree)
        selected_cols <- which(phylo_sig$abun < filter_BM_P)
        abundance <- abundance[, selected_cols, drop = FALSE]
        abun <- abun[, selected_cols, drop = FALSE]
        prop <- prop[, selected_cols, drop = FALSE]
    }

    #return(list(abun=abun, prop=prop, C=C, tree=tree, above_names=above_names))
    return(do_sim_res)
}


check_BM <- function(abundance, tree){
    n <- dim(abundance)[2]
    phylo_sig <- data.frame(P=rep(1,n), K=rep(1,n))
    for(i in 1:dim(abundance)[2]){
        trait <- log(abundance[,i])-log(sum(abundance[,1]))
        trait_data <- data.frame( species=rownames(abundance), trait=trait )
        trait_data$species <- factor(trait_data$species, levels = tree$tip.label)
        trait_values <- trait_data$trait[match(tree$tip.label, trait_data$species)]
        phylo_signal <- suppressMessages(
            phylosig(tree, trait_values, method = "lambda", test = TRUE)
        )
        phylo_sig$P[i] <- phylo_signal$P
        #phylo_sig$K[i] <- phylo_signal$K
    }
    #names(phylo_sig) <- colnames(abundance)
    return(phylo_sig)
}


get_phylo_groups <- function(tree){
    #get the two descedants of the root
    root_node <- Ntip(tree) + 1   # the root node number
    children <- tree$edge[tree$edge[,1] == root_node, 2]
    child1_tips <- sort(tree$tip.label[unlist(Descendants(tree, children[1], type = "tips"))])
    child2_tips <- sort(tree$tip.label[unlist(Descendants(tree, children[2], type = "tips"))])
    group1 <- list(labels = child1_tips, col = 'green')
    group2 <- list(labels = child2_tips, col = 'purple')
    return(list(group1=group1, group2=group2))
}


######################################
create_single_plot <- function(matrix, method = "bray", color = "black", title = "PCoA Plot", group_samples = NULL){
  # Check input type
	if (!is.matrix(matrix) && !is.data.frame(matrix)) {
    stop("Input must be a matrix or data.frame.")
  }
  
  # Compute distance
	diss <- vegan::vegdist(matrix, method = method)
  
  # Perform PCoA (cmdscale)
	pts <- cmdscale(diss, k = 2, eig = TRUE)
  
  # Extract coordinates correctly
	coords <- as.data.frame(pts$points)
	if (ncol(coords) < 2) {
        stop("PCoA returned less than two dimensions — check your input data.")
    }
	colnames(coords) <- c("PC1", "PC2")
	coords$Sample <- rownames(matrix)
	coords$Color <- color  # default color
  
    # Apply group colors if provided
    if (!is.null(group_samples) && is.list(group_samples)) {
        for (grp in group_samples) {
            if (!is.null(grp$labels) && !is.null(grp$col)) {
                coords$Color[coords$Sample %in% grp$labels] <- grp$col
            }
        }
    }
  
    # ---- Plot ----
    xrange <- range(coords$PC1)
    yrange <- range(coords$PC2)
	plot(coords$PC1, coords$PC2,
        pch = 19,
        col = coords$Color,
        xlab = "PC1",
        ylab = "PC2",
        main = title,
        asp = 1,
        xlim = xrange*1.2,
        ylim = yrange*1.2
    )
  
  # Add sample labels
	text(coords$PC1, coords$PC2,
       labels = coords$Sample,
       pos = 4,
       cex = 0.8)
  
    if (!is.null(group_samples)) {
        for (grp in group_samples) {
            sel <- coords$Sample %in% grp$labels
            if (sum(sel) >= 3) { # needs >=3 to compute ellipse
                vegan::ordiellipse(coords[sel, c("PC1","PC2")],
                    rep(1, sum(sel)),
                    kind = 'sd', conf = 0.95, draw = 'polygon',
                    lwd = 1.2, col = grp$col,
                )
            }
        }
    }
}


plot_graphs <- function(m1, m2, m3, outfile, grp_list) {
    par(mfrow = c(2, 2))
    create_single_plot(m1, method = "euclidean", "green", title = "PCoA BC-distance", group_samples = grp_list)
    create_single_plot(m2, method = "euclidean", "cyan", title = "PCoA: Euclidean (m2)", group_samples = grp_list)
    create_single_plot(m3, method = "euclidean", "red", title = "PCoA: Euclidean (m3)", group_samples = grp_list)

    tip_colors <- ifelse(tree$tip.label %in% above_names, "orange", "blue")
    plot(tree, tip.color = tip_colors, cex = 0.3, label.offset = 0.01)
    
}


##################################
read_data <- function(C){
    # reorder
    abundance <- abundance[match(colnames(C), rownames(abundance)), ]
    # delete all zero columns
    abundance <- abundance[, apply(abundance, 2, function(col) any(col != 0))]
    abundance <- abundance+1e-5 # to avoid abundance of zero

    Z <- 1:length(tree$tip.label)
    abundance <- abundance[Z,]
    # phylo covariance matrix, vcv()
    C <- C[Z,Z]

    abun <- abundance #old name: Y
    prop <- abundance #old name: Q
    return(list(C=C, abun=abun, prop=prop))
}


do_transformation <- function(transform, C, log_prop_geomean){
    # calculate the inverse of C in order to calculate the root values
    C_inv <- solve(C)
    # calculate the phylo mean (root value) for each node
    ones <- rep(1, dim(C)[1])
    root_values <- apply(log_prop_geomean, 2, function(col) {
        numerator <- col %*% C_inv %*% ones
        numerator / (t(ones) %*% C_inv %*% ones)
    })

    if (grepl("chol", transform, ignore.case = T)){
        #de-correlation by Cholesky decomposition
        L_inv <- solve(t(chol(C)))
        L_inv <- L_inv * sqrt(diag(C)[1])
        X <- L_inv %*% t((t(log_prop_geomean) - root_values))
        X <- t(t(X) + root_values)
    } else if(grepl("garland", transform, ignore.case = T)){
        # using C^(-0.5)
        eig_decomp <- eigen(C)
        L <- eig_decomp$vectors %*% diag(1/sqrt(eig_decomp$values)) %*% t(eig_decomp$vectors)
        L <- L * sqrt(diag(C)[1])
        X <- L %*% t((t(log_prop_geomean) - root_values))
        X <- t(t(X) + root_values)
    }
    return(X)
}


##################################
# some params to change, XQ
lambda <- 5
mu <- 5
rho <- 0.001
age <- 7.5
is_one <- FALSE
is_sim <- FALSE
is_inter <- FALSE
filter_BM_P <- 1

# host tree tip num
tnum <- 10
# bac (microbiota) taxa num
bnum <- 8

transform <- "garland"
dist_method <- 'euclidean'
is_standardize <- FALSE

outdir <- NULL
is_force <- FALSE


##################################
spec = matrix(c(
    'tree', 't', 2, "character",
    'abundance', 'a', 2, "character",
    'metadata', 'm', 2, "character",
    'one', 'O', 0, "logical",
    'all', 'A', 0, "logical",
    #'transform', 'T', 2, "character",
    'sim', 's', 0, "logical",
    'filter_BM_P', 'p', 2, "double",
    'tnum', 'T', 2, "integer",
    'bnum', 'B', 2, "integer",
    'bd', 'b', 2, "character",
    'dist', 'd', 2, 'character',
    'inter', 'i', 0, "logical",
    'standardize', 'S', 0, "logical",
    'help' , 'h', 0, "logical",
    'outdir', 'o', 1, "character",
    'force', 'f', 0, 'logical'
), byrow=TRUE, ncol=4)

opt <- getopt(spec)


##################################
if (!is.null(opt$one)) {
    is_one <- TRUE
}
if (!is.null(opt$all)) {
    is_one <- FALSE
}

if(!is.null(opt$sim)){
    is_sim = TRUE
}

if(!is.null(opt$inter)){
    is_inter = TRUE
}

if (!is.null(opt$help)) {
    cat(getopt(spec, usage = T))
    q(status = 1)
}

if(! is.null(opt$tree)){
    tree <- read.tree(opt$tree)
    C <- vcv(tree)
    rownames(C) <- colnames(C) <- colnames(vcv(tree))
}

if(! is.null(opt$abundance)){
    abundance <- read.table(opt$abundance, header=T)
}

if (!is.null(opt$metadata)) {
    if (is_one){
        selected_samples <- generate_metadata(opt$metadata)
        overlapping_items <- intersect(colnames(abundance), selected_samples$sample_id)
        new_df <- abundance[, colnames(abundance) %in% overlapping_items]
        name_mapping <- setNames(selected_samples$species, selected_samples$sample_id)
        colnames(new_df) <- name_mapping[colnames(new_df)]
        abundance <- t(new_df)
    } else {
        abundance <- generate_metadata2(opt$metadata, abundance)
        abundance <- t(abundance)
    }
}

if(! is.null(opt$transform)){
    transform <- opt$transform
}

if(! is.null(opt$filter_BM_P)){
    filter_BM_P <- opt$filter_BM_P
}

if(! is.null(opt$tnum)){
    tnum <- opt$tnum
}
if(! is.null(opt$bnum)){
    bnum <- opt$bnum
}

if(! is.null(opt$bd)){
    bd_param <- opt$bd
    params <- as.numeric(strsplit(bd_param, ",")[[1]])
    lambda <- params[1]
    mu     <- params[2]
    rho    <- params[3]
    age    <- params[4]
}

if(! is.null(opt$dist)){
    dist_method <- opt$dist
}

if(! is.null(opt$standardize)){
    is_standardize <- TRUE
}

if(! is.null(opt$force)){
    is_force <- TRUE
}

if(! is.null(opt$outdir)){
    outdir <- opt$outdir
    if (dir.exists(outdir)) {
      if (is_force) {
        message("removing outdir ", outdir, ' ......')
        unlink(outdir, recursive = TRUE, force = TRUE)
      } else {
        stop("outdir ", outdir, " already exists. Use --force. Exiting ......")
      }
    }
    dir.create(outdir, recursive = TRUE)
}


##################################
#---------- start here ----------#
##################################
if(! is_sim){
    prop <- read_data(C)$prop
} else{
    sim_wrapper_result <- sim_wrapper(tnum, bnum, filter_BM_P, lambda, mu, rho, age)
    #col: bac taxa (bnum), row: host species (tnum)
    abun <- sim_wrapper_result$abun
    prop <- sim_wrapper_result$prop
    C <- sim_wrapper_result$C #phylo_cov
    tree <- sim_wrapper_result$tree
    above_names <- sim_wrapper_result$above_names
    Sigma <- sim_wrapper_result$Sigma
    Rho <- sim_wrapper_result$Rho
}


###################################################
# reorder
#Y <- Y[match(colnames(C), rownames(Y)), ]

log_prop <- log(prop+1e-6)
row_geomean_log_prop <- rowMeans(log_prop)
log_prop_geomean <- log_prop

for(i in 1:dim(prop)[1]) # iterate host
{
    log_prop_geomean[i,] <- log(prop[i,]) - row_geomean_log_prop[i]
}


##################################
# P is the transformed matrix
P <- do_transformation(transform, C, log_prop_geomean)
rownames(P) <- rownames(C)
cat("\n\n")


rounded_to <- 3
write.table(round(prop, rounded_to), file = file.path(outdir, 'prop.tbl'), sep = "\t", quote = FALSE)
write.table(round(log_prop, rounded_to), file = file.path(outdir, 'log_prop.tbl'), sep = "\t", quote = FALSE)
write.table(round(log_prop_geomean, rounded_to), file = file.path(outdir, 'log_prop_geomean.tbl'), sep = "\t", quote = FALSE)
write.table(round(P, rounded_to), file = file.path(outdir, 'P.tbl'), sep = "\t", quote = FALSE)
write.table(round(Sigma, rounded_to), file = file.path(outdir, 'Sigma.tbl'), sep = "\t", quote = FALSE)
write.table(round(Rho, rounded_to), file = file.path(outdir, 'Rho.tbl'), sep = "\t", quote = FALSE)


##################################
# output file pdf
outfile <- file.path(outdir, "pcoa.pdf")
pdf(outfile)

#rownames(P) <- rownames(log_prop_geomean)
# normal pcoa, not phylo corrected
pcoa_1 <- calculate_pcoa(log_prop_geomean, dist_method, is_standardize, grp_list)

# phylo corrected
grp_list <- list(group1=list('labels'=above_names, 'col'='orange'), group2=list('labels'=setdiff(tree$tip.label,above_names),'col'='blue'))
if(! is_inter){
    pcoa_2 <- calculate_pcoa(P, dist_method, is_standardize, grp_list)
    plot_graphs(prop, log_prop_geomean, P, outfile, grp_list)
}

##########################################
grp_list <- get_phylo_groups(tree)
plot_graphs(prop, log_prop_geomean, P, outfile, grp_list)

dev.off()

cat(round(pcoa_1$eig/sum(pcoa_1$eig), 3), "\n", round(pcoa_2$eig/sum(pcoa_2$eig), 3), "\n")


